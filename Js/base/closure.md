# 闭包原理

闭包是在返回一个引用了外部作用域变量的函数的时候，为了把环境保存下来，创建的一个快照，并且对作用域链做了tree shaking，只留下必要的闭包链，保存在堆里，作为对象的 [[scopes]] 属性。因为此时还没执行函数，所以要静态分析标识符引用，确定用到了那些变量，打包保存下来。


## 作用域链
在 JavaScript 里面，函数、块、模块都可以形成作用域（一个存放变量的独立空间），他们之间可以相互嵌套，作用域之间会形成引用关系，这条链叫做作用域链。

### 静态作用域链
函数和块的作用域内的变量声明会在作用域 （scope） 内创建一个绑定（变量名绑定到具体的值，也就是 binding），然后其余地方可以引用 （refer） 这个 binding，这样就是静态作用域链的变量访问顺序。

为何叫静态
因为这样的嵌套关系是分析代码就可以得出的，不需要运行，按照这种顺序访问变量的链就是静态作用域链，这种链的好处是可以直观的知道变量之间的引用关系。

相对的，还有动态作用域链，也就是作用域的引用关系与嵌套关系无关，与执行顺序有关，会在执行的时候动态创建不同函数、块的作用域的引用关系。缺点就是不直观，没法静态分析。

静态作用域链是可以做静态分析的，比如我们刚刚用 babel 分析的 scope 链就是。所以绝大多数编程语言都是作用域链设计都是选择静态的顺序。

JavaScript 除了静态作用域链外，还有一个特点就是函数可以作为返回值

``` js
function func() {
  const a = 1;
  return function() {
    console.log(a);
  };
}
const f2 = func();
```

这就导致了一个问题，本来按照顺序创建调用一层层函数，按顺序创建和销毁作用域挺好的，但是如果内层函数返回了或者通过别的暴露出去了，那么外层函数销毁，内层函数却没有销毁，这时候怎么处理作用域，父作用域销不销毁？（比如这里的 func 调用结束要不要销毁作用域）

## 不按顺序的函数调用与闭包
``` js
function func() {
  const guang = 'guang';
  function func2() {
    const ssh = 'ssh';
    function func3() {
      const suzhe = 'suzhe';
    }
    return func3;
  }
  return func2;
}

const func2 = func();
```

当调用 func2 的时候 func1 已经执行完了，这时候销不销毁 ？于是 JavaScript 就设计了闭包的机制。